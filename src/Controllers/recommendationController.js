// controllers/recommendationController.js
const Transaction = require('../Models/Transaction'); // Tu modelo Mongoose Transaction
const { runPythonScript } = require('../utils/pythonBridge'); // Importa la utilidad para llamar a Python

// --- Funciones de Recomendaci√≥n basadas en Mongoose (top frecuencia/monto) ---
// Estas funciones consultan directamente tu base de datos MongoDB
// NO necesitan pasar df_transacciones_con_cluster, operan sobre el modelo Transaction.

async function obtenerProductosTopFrecuencia(clusterId, numProductos = 3) {
    try {
        // Asumiendo que el campo 'cluster' no est√° directamente en la transacci√≥n.
        // Si tienes un modelo de Cliente con 'cluster' asociado, tendr√≠as que poblarlo o filtrar por sus atributos.
        // Para este ejemplo, haremos una b√∫squeda general de productos m√°s frecuentes.
        // Si deseas filtrar por clientes de un CLUSTER ESPEC√çFICO, el clusterId debe ser un atributo en Transaction
        // o debes filtrar las transacciones por atributos que corresponden a ese cluster (ej. rango de monto_total_gastado).
        // Por simplicidad, aqu√≠ se obtienen los productos m√°s frecuentes GENERALES.
        // Si el cliente_nombre se puede mapear a un cluster sin un modelo Cliente, es m√°s complejo.
        
        // Si tu modelo Transaction tuviera un campo 'cluster_cliente':
        // const topProducts = await Transaction.aggregate([
        //     { $match: { cluster_cliente: clusterId } },
        //     { $group: { _id: '$producto_nombre', count: { $sum: 1 } } },
        //     { $sort: { count: -1 } },
        //     { $limit: numProductos }
        // ]);

        // Opci√≥n general si no tienes el cluster en Transaction:
        const topProducts = await Transaction.aggregate([
            { $group: { _id: '$producto_nombre', count: { $sum: 1 } } },
            { $sort: { count: -1 } },
            { $limit: numProductos }
        ]);
        return topProducts.map(p => p._id);
    } catch (error) {
        console.error(`Error al obtener productos top por frecuencia:`, error.message);
        return [];
    }
}

async function obtenerProductosTopMonto(clusterId, numProductos = 3) {
    try {
        // Similar a la funci√≥n anterior, si tu Transaction no tiene 'cluster_cliente',
        // esta obtendr√° los productos que m√°s monto generan en general.
        const topProducts = await Transaction.aggregate([
            { $group: { _id: '$producto_nombre', totalMonto: { $sum: '$monto_total' } } },
            { $sort: { totalMonto: -1 } },
            { $limit: numProductos }
        ]);
        return topProducts.map(p => p._id);
    } catch (error) {
        console.error(`Error al obtener productos top por monto:`, error.message);
        return [];
    }
}

// --- Controlador de Express para Recomendaciones (funci√≥n principal) ---

/**
 * @desc    Genera recomendaciones de productos para un cliente basado en una nueva transacci√≥n.
 * Las m√©tricas del cliente se calculan al momento de la solicitud.
 * @route   POST /api/recommendations (o llamada interna)
 * @access  Private (requiere autenticaci√≥n/autorizaci√≥n)
 * @param   {Object} req - Objeto de solicitud de Express, esperando `nueva_transaccion` en `req.body`.
 * @param   {Object} res - Objeto de respuesta de Express.
 * @returns {Object} JSON con el estado de la operaci√≥n y las recomendaciones.
 */
exports.getRecommendationsForTransaction = async (req, res) => {
    try {
        const nuevaTransaccion = req.body;
        const clienteAfectadoEmail = nuevaTransaccion.cliente_nombre;
        const productoBaseParaReglas = nuevaTransaccion.producto_nombre;

        // --- 1. Calcular M√©tricas del Cliente Sobre la Marcha ---
        // Se buscan todas las transacciones del cliente (incluyendo la que se acaba de guardar si esta funci√≥n es llamada POST-SAVE)
        const transaccionesExistentesCliente = await Transaction.find({ cliente_nombre: clienteAfectadoEmail });

        let numTransaccionesActual = transaccionesExistentesCliente.length;
        let montoTotalGastadoActual = transaccionesExistentesCliente.reduce((sum, t) => sum + t.monto_total, 0);
        
        console.log(`\nM√©tricas calculadas para '${clienteAfectadoEmail}':`);
        console.log(`Transacciones: ${numTransaccionesActual}, Gasto Total: ${montoTotalGastadoActual}`);

        // --- 2. Enviar Datos a Python para Clasificar Cl√∫ster y Obtener Reglas de Asociaci√≥n ---
        const pythonInput = {
            cliente_data_actualizada: {
                num_transacciones: numTransaccionesActual,
                monto_total_gastado: montoTotalGastadoActual
            },
            producto_base_para_reglas: productoBaseParaReglas
        };

        let pythonResult;
        try {
            pythonResult = await runPythonScript('predict_and_recommend.py', pythonInput);
        } catch (pyError) {
            console.error('Error al ejecutar el script Python:', pyError.message);
            // Si hay un error en Python, respondemos con un error para el cliente
            return res.status(500).json({ success: false, error: `Error en el servicio de ML: ${pyError.message}` });
        }

        const nuevoClusterPredicho = pythonResult.cluster;
        const sugerenciasReglas = pythonResult.sugerencias_reglas; // ¬°Estas vienen de Python!

        console.log(`El cliente '${clienteAfectadoEmail}' (con la nueva transacci√≥n) ahora pertenece al Cl√∫ster: ${nuevoClusterPredicho}`);
        
        // --- 3. Generar Recomendaciones Integradas (incluyendo las de Mongoose) ---
        const recomendaciones = {
            sugerencias_cluster: [],
            sugerencias_reglas: sugerenciasReglas // ¬°Aqu√≠ est√°n las reglas de asociaci√≥n de Python!
        };

        // Recomendaci√≥n por Cl√∫ster (Perfil del Cliente) - Calculado en Node.js con Mongoose
        console.log(`\nüî• Vestidos TOP para tu perfil (Cl√∫ster ${nuevoClusterPredicho}):`);
        let sugerenciasCluster = [];
        // Las funciones obtenerProductosTopFrecuencia y obtenerProductosTopMonto
        // ahora NO usan un `df_transacciones_con_cluster_local` de Pandas.
        // Hacen una consulta directa a MongoDB a trav√©s de Mongoose.
        // NOTA: Si necesitas que estas funciones filtren por 'clusterId',
        // el clusterId debe estar en el modelo Transaction o debes implementar
        // una l√≥gica de filtrado m√°s sofisticada basada en los atributos del cliente.
        // Por ahora, estas dar√°n los top productos generales.

        if (nuevoClusterPredicho === 0) {
            sugerenciasCluster = await obtenerProductosTopMonto(nuevoClusterPredicho, 3);
            console.log("Sugerencias de productos (basadas en alto ingreso para el cl√∫ster):");
            console.log("Acci√≥n estrat√©gica: Ofr√©cele descuentos exclusivos o acceso anticipado a colecciones premium.");
        } else if (nuevoClusterPredicho === 1) {
            sugerenciasCluster = await obtenerProductosTopFrecuencia(nuevoClusterPredicho, 3);
            console.log("Sugerencias de productos (basadas en frecuencia para el cl√∫ster):");
            console.log("Acci√≥n estrat√©gica: Sugiere productos complementarios o programas de fidelidad para aumentar el valor promedio de su compra.");
        } else if (nuevoClusterPredicho === 2) {
            sugerenciasCluster = await obtenerProductosTopMonto(nuevoClusterPredicho, 3);
            console.log("Sugerencias de productos (basadas en alto ingreso para el cl√∫ster):");
            console.log("Acci√≥n estrat√©gica: Recu√©rdale las √∫ltimas novedades de lujo o productos de alta gama que suelen interesarle.");
        } else {
            console.log("Cl√∫ster no reconocido. Ofrecer recomendaciones generales (top m√°s vendidos).");
            const topProductsOverall = await Transaction.aggregate([
                { $group: { _id: '$producto_nombre', count: { $sum: 1 } } },
                { $sort: { count: -1 } },
                { $limit: 3 }
            ]);
            sugerenciasCluster = topProductsOverall.map(p => p._id);
        }

        if (sugerenciasCluster.length > 0) {
            recomendaciones.sugerencias_cluster = sugerenciasCluster;
            sugerenciasCluster.forEach(prod => console.log(`- ${prod}`));
        } else {
            console.log("No se encontraron sugerencias de productos para este cl√∫ster.");
        }

        // Recomendaci√≥n por Reglas de Asociaci√≥n (Productos Relacionados)
        console.log(`\nüõçÔ∏è Combina con tu '${productoBaseParaReglas}':`);
        if (sugerenciasReglas && sugerenciasReglas.length > 0) {
            sugerenciasReglas.forEach(rec => {
                // Aseg√∫rate de que rec.confianza sea un n√∫mero para el toFixed
                console.log(`- ${rec.producto} (Confianza: ${(rec.confianza * 100).toFixed(1)}%)`);
            });
        } else {
            console.log("No se encontraron productos complementarios basados en h√°bitos de compra anteriores.");
        }

        // Env√≠a la respuesta final (con recomendaciones de cluster y reglas)
        // Nota: Si esta funci√≥n es llamada internamente (desde createTransaction),
        // `res` ser√° el mockRes, y no enviar√° una respuesta HTTP real hasta que createTransaction lo haga.
        res.status(200).json({
            success: true,
            message: 'Recomendaciones generadas exitosamente.',
            recommendations: recomendaciones
        });

    } catch (error) {
        console.error(`Error al generar recomendaciones: ${error.message}`);
        res.status(500).json({ success: false, error: 'Error del servidor al generar recomendaciones.' });
    }
};

// --- (Otras funciones como createTransaction, updateTransaction, etc., si est√°n en este mismo archivo) ---
// Normalmente, createTransaction estar√≠a en transactionController.js y llamar√≠a a esta funci√≥n.
// --- Funci√≥n createTransaction original (si aplica) ---
exports.createTransaction = async (req, res) => {
    try {
        console.log(req.body)
        const transaction = await Transaction.create(req.body);
        res.status(201).json({
            success: true,
            data: transaction
        });
    } catch (error) {
        console.error(`Error al crear transacci√≥n: ${error.message}`);
        if (error.name === 'ValidationError') {
            const messages = Object.values(error.errors).map(val => val.message);
            return res.status(400).json({ success: false, error: messages });
        }
        res.status(500).json({ success: false, error: 'Error del servidor al crear la transacci√≥n.' });
    }
};